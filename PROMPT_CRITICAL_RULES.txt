**CRITICAL RULES - READ CAREFULLY:**
1. ALWAYS use selectors from the database - they are pre-verified
2. Match elements using text, visual properties, and context
3. Use vanilla JavaScript ONLY - no jQuery, no libraries
4. **IMPLEMENT EVERY ASPECT OF THE USER REQUEST** - DO NOT SKIP ANY PART
5. For color changes, ALWAYS use element.style.backgroundColor = 'colorname' or '#hexcode'
6. For text changes, ALWAYS use element.textContent = 'new text'
7. If user mentions BOTH text AND color, your code MUST include BOTH
8. Prefer JavaScript for styling (inline styles override CSS and are easier to test)
9. If an element isn't in the database, it doesn't exist - don't make up selectors
10. **CRITICAL: ALL setInterval/setTimeout MUST be registered with Cleanup Manager** (see below)

**CLEANUP MANAGER - MANDATORY FOR ALL INTERVALS/TIMEOUTS:**
The Cleanup Manager tracks and cleans up intervals/timeouts between preview applications.
**YOU MUST REGISTER ALL INTERVALS AND TIMEOUTS** to prevent state corruption.

// ✅ CORRECT - Register interval with Cleanup Manager:
const intervalId = setInterval(() => {
  updateCountdown();
}, 1000);
if (window.ConvertCleanupManager) {
  window.ConvertCleanupManager.registerInterval(intervalId, 'countdown timer');
}

// ✅ CORRECT - Register timeout with Cleanup Manager:
const timeoutId = setTimeout(() => {
  showBanner();
}, 5000);
if (window.ConvertCleanupManager) {
  window.ConvertCleanupManager.registerTimeout(timeoutId, 'delayed banner');
}

// ✅ CORRECT - Register created elements:
const banner = document.createElement('div');
banner.id = 'countdown-banner';
document.body.appendChild(banner);
if (window.ConvertCleanupManager) {
  window.ConvertCleanupManager.registerElement(banner, 'countdown banner');
}

// ❌ WRONG - Untracked interval will persist between previews:
setInterval(() => updateCountdown(), 1000);  // ← NOT REGISTERED, CAUSES BUGS!

**NOTE:** waitForElement() automatically registers its own intervals - you don't need to register those.

**WRAPPER CONTAINER RULES - CRITICAL FOR LAYOUT:**

When creating dynamic HTML with wrapper elements, you MUST style ALL containers explicitly:

// ❌ WRONG - Wrapper has no flex styling, children stack vertically:
banner.innerHTML = '<span>Text</span><div class="wrapper"></div>';
wrapper.innerHTML = '<div class="box">1</div><div class="box">2</div>';
// CSS only styles .box, NOT .wrapper
.box { background: red; }  // ← Missing .wrapper { display: flex; }

// ✅ CORRECT - Wrapper has explicit flex styling:
banner.innerHTML = '<span>Text</span><div class="wrapper"></div>';
wrapper.innerHTML = '<div class="box">1</div><div class="box">2</div>';
// CSS styles BOTH .wrapper AND .box
.wrapper {
  display: flex !important;
  gap: 10px !important;
}
.box { background: red; }

**CRITICAL RULES FOR WRAPPERS:**
1. If you create a wrapper div (class="wrapper", class="container", etc.)
2. And you want child elements to be horizontal
3. You MUST add CSS: .wrapper { display: flex !important; gap: 10px !important; }
4. Flex on parent does NOT inherit to grandchildren - style each level

**COMMON MISTAKE - COUNTDOWN TIMERS:**
// ❌ WRONG - Boxes will stack vertically:
const banner = document.createElement('div');
banner.id = 'countdown';
banner.style.display = 'flex';  // ← This is on the banner
banner.innerHTML = '<div class="countdown-wrapper"></div>';
wrapper.innerHTML = '<div class="box">1d</div><div class="box">2h</div>';
// CSS missing: .countdown-wrapper { display: flex; }

// ✅ CORRECT - Boxes will be horizontal:
const banner = document.createElement('div');
banner.id = 'countdown';
banner.innerHTML = '<div class="countdown-wrapper"></div>';
// CSS for BOTH levels:
#countdown { display: flex !important; }
#countdown .countdown-wrapper { display: flex !important; gap: 10px !important; }
#countdown .box { padding: 8px !important; }

**DATE/TIME HANDLING - KEEP IT SIMPLE:**

Avoid complex timezone calculations. Use simple, working patterns:

// ✅ CORRECT - Simple countdown to specific date:
const targetDate = new Date('2025-12-31T23:59:59').getTime();
function updateCountdown() {
  const now = Date.now();
  const diff = targetDate - now;
  if (diff <= 0) {
    banner.style.display = 'none';
    return;
  }
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  // Update display...
}
const intervalId = setInterval(updateCountdown, 1000);
if (window.ConvertCleanupManager) {
  window.ConvertCleanupManager.registerInterval(intervalId, 'countdown');
}

// ✅ CORRECT - Next Friday at midnight:
function getNextFriday() {
  const now = new Date();
  const day = now.getDay();
  const daysUntilFriday = (5 - day + 7) % 7 || 7;
  const friday = new Date(now.getTime() + daysUntilFriday * 24 * 60 * 60 * 1000);
  friday.setHours(0, 0, 0, 0);
  return friday.getTime();
}

// ❌ WRONG - Complex timezone math that might fail:
const ptFormatter = new Intl.DateTimeFormat('en-US', { timeZone: 'America/Los_Angeles', ... });
const parts = ptFormatter.formatToParts(nextFriday);
// ... 30 lines of complex parsing ...

**CODE PATTERNS:**

// ✅ CORRECT - User asks to change text AND color:
waitForElement('a.btn.btn--solid', (element) => {
  element.textContent = 'Act Now: Build Your Mailbox!';  // ← Text change
  element.style.backgroundColor = 'red';                   // ← Color change
  element.style.color = 'white';                           // ← Optional: ensure contrast
});

// ❌ WRONG - Only changes text when user asked for color too:
waitForElement('a.btn.btn--solid', (element) => {
  element.textContent = 'Act Now: Build Your Mailbox!';  // ← Missing color!
});

// ❌ WRONG - Only changes color when user asked for text too:
waitForElement('a.btn.btn--solid', (element) => {
  element.style.backgroundColor = 'red';  // ← Missing text!
});

**COMMON COLORS:**
Use these exact names or hex codes:
- 'red' or '#FF0000' or '#E74C3C'
- 'blue' or '#0000FF' or '#3498DB'
- 'green' or '#00FF00' or '#27AE60'
- 'orange' or '#FFA500' or '#E67E22'
- 'purple' or '#800080' or '#9B59B6'
- 'black' or '#000000'
- 'white' or '#FFFFFF'

**BEFORE RESPONDING - CHECKLIST:**
□ Did I read the ENTIRE user request?
□ Did I identify ALL requested changes (text, color, style, etc.)?
□ Did I implement EVERY change in my code?
□ Am I using selectors from the database ONLY?
□ Did I use element.style.backgroundColor for color changes?
□ Did I use element.textContent for text changes?
□ Does my code include waitForElement for reliability?
